# VSS (Virtual Stack Simd)

---
#### Выполнил: Захарченко Роман Владимирович, группа Р3231, ису: 408648

Вариант: `forth | stack | harv | mc | tick | binary | stream | mem | cstr | prob2 | vector`

# Язык программирования

---


## Синтаксис

``` ebnf
program ::= sections

sections ::= section
          | section sections

section ::= import_section
         | data_section
         | func_section
         | text_section

import_section ::= _import_ <новая строка> path_list

path_list ::= path
           | path path_list

path ::= string

data_section ::= _data_ <новая строка> var_decls

var_decls ::= var_decl
           | var_decl var_decls

var_decl ::= string number "VAR" word 
          | string "VAR" word 
          | number "VAR" word 

func_section ::= _func_ <новая строка> word_def

word_def ::= ":" word terms ";"

text_section ::= _text_ <новая строка> terms

terms ::= term
       | term terms

term ::= word
      | number
      | string
      | address
      | comment
      | if_expr
      | loop_expr_while
      | begin_loop_expr

if_expr ::= "IF" terms "THEN"
         | "IF" terms "ELSE" terms "THEN"

loop_expr_while ::= "LOOP" terms "WHILE" terms "REPEAT"

begin_loop_expr ::= "BEGIN" terms "WHILE" terms "REPEAT"

address ::= "&" word

comment ::= # <любые печатные символы до переноса строки>

string ::= "<любые печатные символы>"

number ::= <целое число>
```
Подробную документацию всех команд можно посмотреть [тут](./docs/forth.md)

Примеры программ можно посмотреть вот [тут](./example)

## Семантика
- Стратегия вычислений - стековая.
- Постфиксная запись (обратная польская нотация).
- Стек данных, стек векторов — основные механизмы передачи аргументов между функциями.
- Стек возвратов — хранит адреса возврата для управления потоком выполнения.
- Forth код компилируется в язык мнемоник который кладётся в директорию build 
- Язык мнемоник транслируется в память инструкций, потом последовательно выполняется.
- Файлы можно импортировать друг в друга. Импорты являются inline вставкой функций в файл куда импортируются.
- Область видимости: все переменные и все функции доступны везде в пределах одного файла, с условием, что переменные и функции объявлены до исполняемого кода.
- Типизация слабая. Термом "<последовательность_символов>" объявляются строки, любое число определяется как знаковое. Строки, записанные не в указанном формате, трактуются как названия переменных или функций. Число может быть записано в десятичном или шестнадцатиричном формате.

# Архитектура процессора

---
## Организация памяти

Память команд и данных раздельная (Гарвардская архитектурa). 
В памяти команд сначала хранятся все функции, потом основной код программы.
Размер машинного слова - 32 бита. Адресация только прямая, но с помощью последовательного применения команды загрузки можно добиться косвенной.

### Память данных
 - Представляет собой последовательность байт адресуемых по машинному слову (32 бита в big-endian)
 - Поддерживает только абсолютную адресацию
 - Адреса 0x80 и 0x84 зарезервированные под ввод вывод

### Память инструкций
 - Первыми 4 байтами в памяти инструкций является адрес входа в программу
 - Представляет собой последовательность байт разделённую на инструкции по 1 или 5 байт в зависимости от наличия аргумента у инструкции. 
 - Процедуры хранятся рядом с основным кодом, но обязательно перед ним т.е. сначала идут все процедуры, а после этого основной код программы
 - Поддерживает абсолютную и относительную адресацию

### Регистры

- PC -- program counter. Хранит указатель на ячейку с исполняемой командой. 32 бита.
- A -- A register. Регистр a. 32 бита.
- B -- B register. Регистр b. 32 бита.

### Стеки
Все стеки представляют собой набор регистров организованный как LIFO-буфер. Они имеют фиксированный размер, аппаратный указатель стека. 
При переполнении происходит исключение самого последнего значения.

В данной стековой машине есть 3 вида стека.
- data stack -- 32-ух битный стек для вычислений, передачи переменных в функции и т.д.
- vector stack -- 128-ми битный стек для векторных вычислений.
- return stack -- 32-ух битный стек для хранения адресов возвратов.

### Доступные программисту ресурсы

#### Регистры, стеки, память

- Регистры общего назначения
  - A, B -- регистры общего назначения (B затираемый регистр при различных загрузках и т.д.)
  - косвенный доступ к PC через операции ветвления 
- Стеки
  - data stack
  - vector stack 
- Память данных (чтение и запись)
- Память инструкций (запись)

#### Работа с памятью

Понятия константы не существует, любые данные можно изменить. 
Любому числу отведено в памяти одно машинное слово, любому символу строки отведён 1 байт -> в одно машинное слово можно записать 4 символа.
Адресация в байтах начиная с 0x0.

## Система команд

### Общие принципы:

- Обработка данных осуществляется по текущему адресу. Процессор считывает 1 байт из памяти.
- Далее считанный байт(opcode) попадает в дешифратор инструкций и если инструкция с аргументом то запрашивается ещё 4 байта и они попадают в регистр B. Сам опкод попадает в OP-ROM откуда получает адрес начала микропрограммы.
- Поток управления:
    - инкремент или увеличение на 4 `PC`
    - условный переход (`if`, `-if`).
    - безусловный переход (`jmp`, `call`)
- Адресация переходов косвенная.
- Адресация загрузок прямая.
- Поток ввода-вывода осуществляется через Memory-Mapped IO. 0x80 - ячейка ввода, 0x84 - ячейка вывода.

### Набор инструкций

Система команд относится к классу стековых архитектур с поддержкой SIMD операций. Основные особенности:
- Стековая модель вычислений
- Поддержка скалярных и векторных операций
- Фиксированный формат команд (8-битный опкод)
- Разделение на арифметико-логические, загрузки/сохранения и управления потоком команд

Все команды кодируются 8-битным опкодом (1 байт). Некоторые команды требуют дополнительного непосредственного значения (imm), которое следует сразу после опкода (4 байта).

---

**Полное описание всех доступных инструкций, их микрокода и т.д. можно найти [тут](./docs/isa.md)**

---

### Классификация системы ~~команд~~
1. **Тип архитектуры**: Стековая с регистрами A/B
2. **Организация памяти**: Гарвардская
3. **Типы операций**:
   - Скалярные
   - Векторные (SIMD)
   - Управление потоком
4. **Особенности**:
   - Единообразное кодирование (1 байт)
   - Два стека (данных/вызовов)
   - Гибридная модель выполнения

### Бинарное представление

Бинарное представление инструкций (всё представлено в big-endian)

Команда с аргументом:
```text

    ┌───────────┬───────────┬───────────┬───────────┬───────────┐
    │ 7... ...0 │ 15..  ..8 │ 23.. ..16 │ 31.. ..24 │ 39.. ..32 │
    ├───────────┼───────────┴───────────┴───────────┴───────────┤
    │   опкод   │                    аргумент                   │
    └───────────┴───────────────────────────────────────────────┘
```


Команда без аргумента:
```text

    ┌───────────┐
    │ 7... ...0 │ 
    ├───────────|
    │   опкод   │ 
    └───────────┘
```

Подробнее про все команды, их коды и их микропрограммную реализацию можно посмотреть тут 
[инструкции](./src/stack_machine/config/instructions.yaml),
[микропрограммы](./src/stack_machine/config/mc.yaml)


# Запуск

---


Для языка forth была разработана системы компиляции и ассемблирования программы в машинный код. 
Сам компилятор делится на 2 части. 
  1. Компилятор Forth кода в язык мнемоник
  2. Ассемблер языка мнемоник в байт-код.

Далее уже запускается стековая машина с указанием бинарных файлов инструкций и данных

## Компилятор 

---

### Интерфейс

Входные данные: имя файла .forth с текстом программы

Выходные данные: файл code с программой на языке мнемоник 

Пример запуска: `python3 -m src.code_compiler.compiling.compiling arrays.forth`

После запуска рядом с файлом forth появится папка build где будет лежать файл `code` с скомпилированной программой в язык мнемоник

### Компиляция

Процесс компиляции состоит из 3 этапов:
  1. Парсинг каждой секции - на этом этапе все секции одного типа объединяются для последующей компиляции
  2. Компиляция каждой из секций - на этом этапе происходит компиляция всех секций в определённом порядке: `_import_`, `_data_`, `_func_`, `_text_`
     такие блоки как `_import_` рекурсивно компилируют своё содержимое однако используя для переменных другое адресное пространство.  
      - Перевод базовых команд в мнемоники (`+` -> `+`, `0` -> `push_imm 0` и т.д.)
      - Разрешение сложных конструкций таких как циклы и ветвление по заготовленным заранее [шаблонам](./src/code_compiler/compiling/app/samples). 
        Данные шаблоны заранее составленными для общих случаев циклов или ветвелний 
  3. Перестановка секций в нужном порядке и запись в результирующий файл - на этом этапе результаты компиляции записываются в
     файл в определённом порядке, сначала идёт секция `.data` далее `.text` в котором идут сначала все скомпилированные функции, потом метка `_start`
     Показывающая место входа в программу и уже потом основная программа.

## Асемблер

---

### Интерфейс

Входные данные: файл с текстом программы на языке мнемоник и числовое значение размера памяти данный в байтах.

Выходные данные: бинарный файл в формате 

```text

    ┌────────────────┬──────────────┬──────────────┬───────────┬───────┬────────┬────────────────┐
    │    32 bits     │    32 bits   │    32 bits   │  .......  │ ..... │ 32 bit │    .......     │
    ├────────────────┼──────────────┼──────────────┼───────────┼───────┼────────┼────────────────┤
    │ clusters count │ cluster size │ cluster addr │  cluster  │       │ _start │  instructions  │
    └────────────────┴──────────────┴──────────────┴───────────┴───────┴────────┴────────────────┘
```
- `clusters count` - количество кластеров данных
- `cluster size` - размер одного кластера
- `cluster addr` - адрес одного кластера
- `cluster` - адрес одного кластера
- `_start` - адрес входа в программу
- `instructions` - все остальные инструкции и их операнды

Пример запуска: `python3 -m src.code_compiler.assembly.assembly code 100`

После запуска рядом с файлом `code` появится папка `bin` в которой будут лежать 2 файла `instruction_memory` и `data_memory` в которых будут находиться инструкции и данные в бинарном фиде соответственно.

### Ассемблирование

На этапе ассемблирования команда преобразует мнемоники, описанные в секции `.text`, в машинный код с использованием [конфигурации инструкций](./src/code_compiler/config/instructions.yaml). При обнаружении метки `_start` её адрес записывается в первое машинное слово памяти инструкций как точка входа программы.

Каждая инструкция занимает 1 байт, за ней следует аргумент длиной 4 байта, если он предусмотрен данной инструкцией.

Данные, описанные в секции `.data`, размещаются в бинарном файле памяти данных. Поддерживаются два типа записи:

- `word` — запись значения в 4 байта;
- `byte` — запись значения в 1 байт.


## Модель процессора

---
Входные данные: путь к бинарным, сгенерированному компилятором, путь к конфигу .yaml, где описаны io, логи, ассерты

Пример запуска:
`
python3 -m src.stack_machine.start_cpu -c arrays.yaml -b ecex.bin
`

Ключ `-с` указывает на то что файл является файлом конфигурации

Ключ `-b` указывает на то что файл является бинарным файлом программы

Пример файла конфигурации можно найти [тут](./example/arrays/arrays.yaml)

Правила написания конфигурации можно найти [тут](./docs/сonfiguration_rules.md)

### Cхема DataPath

### Cхема ControlUnit


### Особенности работы модели:

---

## Тестирование

---
