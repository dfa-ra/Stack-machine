# VSS (Virtual Stack Simd)

---
#### Выполнил: Захарченко Роман Владимирович, группа Р3231, ису: 408648

Вариант: `forth | stack | harv | mc | tick | binary | stream | mem | cstr | prob2 | vector`

# Язык программирования

---


## Синтаксис

``` ebnf
program ::= sections

sections ::= section
          | section sections

section ::= import_section
         | data_section
         | func_section
         | text_section

import_section ::= _import_ <новая строка> path_list

path_list ::= path
           | path path_list

path ::= string

data_section ::= _data_ <новая строка> var_decls

var_decls ::= var_decl
           | var_decl var_decls

var_decl ::= string number "VAR" word 
          | string "VAR" word 
          | number "VAR" word 

func_section ::= _func_ <новая строка> word_def

word_def ::= ":" word terms ";"

text_section ::= _text_ <новая строка> terms

terms ::= term
       | term terms

term ::= word
      | number
      | string
      | address
      | comment
      | if_expr
      | loop_expr_while
      | begin_loop_expr

if_expr ::= "IF" terms "THEN"
         | "IF" terms "ELSE" terms "THEN"

loop_expr_while ::= "LOOP" terms "WHILE" terms "REPEAT"

begin_loop_expr ::= "BEGIN" terms "WHILE" terms "REPEAT"

address ::= "&" word

comment ::= # <любые печатные символы до переноса строки>

string ::= "<любые печатные символы>"

number ::= <целое число>
```
Подробную документацию всех команд можно посмотреть [тут](./docs/forth.md)

Примеры программ можно посмотреть вот [тут](./example)

## Семантика
- Стратегия вычислений - стековая.
- Постфиксная запись (обратная польская нотация).
- Стек данных, стек векторов — основные механизмы передачи аргументов между функциями.
- Стек возвратов — хранит адреса возврата для управления потоком выполнения.
- Forth код компилируется в язык мнемоник который кладётся в директорию build 
- Язык мнемоник транслируется в память инструкций, потом последовательно выполняется.
- Файлы можно импортировать друг в друга. Импорты являются inline вставкой функций в файл куда импортируются.
- Область видимости: все переменные и все функции доступны везде в пределах одного файла, с условием, что переменные и функции объявлены до исполняемого кода.
- Типизация слабая. Термом "<последовательность_символов>" объявляются строки, любое число определяется как знаковое. Строки, записанные не в указанном формате, трактуются как названия переменных или функций. Число может быть записано в десятичном или шестнадцатиричном формате.

# Архитектура процессора

---
## Организация памяти

Модель памяти процессора:

Память команд и данных раздельная (Гарвардская архитектурa). 
В памяти команд сначала хранятся все функции, потом основной код программы.

Регистры:
- PC -- program counter. Хранит указатель на ячейку с исполняемой командой. 32 бита.
- A -- A register. Регистр a. 32 бита.
- B -- B register. Регистр b. 32 бита.

Стеки:
- data stack -- 32-ух битный стек для вычислений, передачи переменных в функции и т.д.
- vector stack -- 128-ми битный стек для векторных вычислений.
- return stack -- 32-ух битный стек для хранения адресов возвратов.



Размер машинного слова - 32 бита. Адресация только прямая, но с помощью последовательного применения команды загрузки можно добиться косвенной.

Понятия константы не существует, любую переменную можно изменить. Любому числу отведено в памяти одно машинное слово, любому символу строки отведён 1 байт -> в одно машинное слово можно записать 4 символа.

Для ввода и вывода используются адреса 0x80 и 0x84 памяти данных.

При компиляции кода из языка forth в язык мнемоник компилятор записывает сначала все функции и после них обозначает место начала основного кода как _start. При трансляции языка мнемоник основываясь на данной метке 
выбирается место для входа в программу.


## ISA

### Особенности процессора:

- Обработка данных осуществляется по текущему адресу. Процессор считывает 1 байт из памяти.
- Далее считанный байт(opcode) попадает в дешифратор инструкций и если инструкция с аргументом то запрашивается ещё 4 байта и они попадают в регистр B. Сам опкод попадает в OP-ROM откуда получает адрес начала микропрограммы.
- Поток управления:
    - инкремент или увеличение на 4 `PC`
    - условный переход (`if`, `-if`).
    - безусловный переход (`jmp`, `call`)
- Адресация переходов косвенная.
- Адресация загрузок прямая.
- Поток ввода-вывода осуществляется через Memory-Mapped IO. 0x80 - ячейка ввода, 0x84 - ячейка вывода.

### Набор инструкций

Существует три типа команд: с аргументом и без аргумента. Опкод занимает 1 байт, аргумент 4 байта.

Команды с аргументом:
- Стеком данных
  - `push_imm`  -- прямая загрузка данных в стек
  - `lw_from_imm_addr`  -- загрузка в стек данных по адресу, переданному команде
  - `sw_to_imm_addr`  -- запись верха стека по адресу, переданному команде
- Векторный стек
  - `v_lw_from_imm_addr`  -- загрузка в стек векторов по адресу, переданному команде
  - `v_sw_to_imm_addr`  -- запись верха стека векторов по адресу, переданному команде
- `jmp`  -- переход на относительное количество инструкций
- `call`  -- вызов функции
- `if`  -- проверка, является ли верхнее значение стека 0 и если да — переход на указанный адрес
- `-if`  -- проверка, не является ли верхнее значение стека 0 и если нет — переход на указанный адрес

Команды без аргумента:
- Стеком данных
  - `lw_from_a_addr`  -- загрузка в стек данных по адресу в регистре a
  - `lw_from_b_addr`  -- загрузка в стек данных по адресу в регистре b
  - `lw_from_a_addr_inc_a`  -- загрузка данных по адресу в регистре a, a = a + 1
  - `load_T_a_pop`  -- загрузка вершины стека в a с попом стека
  - `load_T_b_push`  -- загрузка вершины стека в b с попом стека
  - `dup`  -- дублирование верха стека
  - `sw_to_a_addr`  -- запись верха стека по адресу в регистре a
  - `sw_to_b_addr`  -- запись верха стека по адресу в регистре b
  - `sw_to_a_addr_inc_a`  -- запись верха стека по адресу в регистре a, a = a + 1
  - `push_a`  -- запушить значение a в стек
  - `push_a_inc`  -- запушить значение a в стек
  - `pop`  -- попнуть стек
  - `push_b`  -- запушить значение b в стек
  - `+`  -- сложение 2 верхних значений стека
  - `-`  -- вычитание 2 верхних значений стека
  - `*`  -- умножение 2 верхних значений стека
  - `/`  -- деление 2 верхних значений стека
  - `<<`  -- сдвиг влево верха стека
  - `>>`  -- сдвиг вправо верха стека
  - `not`  -- побитовое отрицание верха стека
  - `and`  -- побитовое "и" 2 верхних значений стека
  - `or`  -- побитовое "или" 2 верхних значений стека
  - `inc`  -- инкрементация верхнего значения стека
  - `over`  -- swap 2 верхних значений стека


- Векторным стек
  - `v_lw_from_a_addr`  -- загрузка в стек по адресу в регистре a
  - `v_lw_from_b_addr`  -- загрузка в стек по адресу в регистре b
  - `v_sw_to_a_addr`  -- запись верха стека по адресу в регистре a
  - `v_sw_to_b_addr`  -- запись верха стека по адресу в регистре b
  - `v_pop`  -- попнуть стек
  - `v+`  -- сложение 2 верхних значений стека
  - `v-`  -- вычитание 2 верхних значений стека
  - `v*`  -- умножение 2 верхних значений стека
  - `v/`  -- деление 2 верхних значений стека
  - `v<<`  -- сдвиг влево верха стека 
  - `v>>`  -- сдвиг вправо верха стека 
  - `v_not`  -- побитовое отрицание верха стека 
  - `v_and`  -- побитовое "и" 2 верхних значений стека 
  - `v_or`  -- побитовое "или" 2 верхних значений стека
  - `v_inc`  -- инкрементация верхнего значения стека
  - `v_over`  -- swap 2 верхних значений стека 
- `ret`  -- возврат из функции
- `halt`  -- конец программы

### Бинарное представление

Бинарное представление инструкций (всё представлено в big-endian)

Команда с аргументом:
```text

    ┌───────────┬───────────┬───────────┬───────────┬───────────┐
    │ 7... ...0 │ 15..  ..8 │ 23.. ..16 │ 31.. ..24 │ 39.. ..32 │
    ├───────────┼───────────┴───────────┴───────────┴───────────┤
    │   опкод   │                    аргумент                   │
    └───────────┴───────────────────────────────────────────────┘
```


Команда без аргумента:
```text

    ┌───────────┐
    │ 7... ...0 │ 
    ├───────────|
    │   опкод   │ 
    └───────────┘
```

Подробнее про все команды, их коды и их микропрограммную реализацию можно посмотреть тут 
[инструкции](./src/stack_machine/config/instructions.yaml),
[микропрограммы](./src/stack_machine/config/mc.yaml)


# Запуск

---


Для языка forth был разработан системы компиляции и ассемблирования программы в машинный код. 
Сам компилятор делится на 2 части. 
  1. Компилятор Forth кода в язык мнемоник и ассемблер
  2. Ассемблер языка мнемоник в байт код.

Далее уже запускается стековая машина с указанием бинарных файлов инструкций и данных

## Компилятор 

---

### Интерфейс

Входные данные: имя файла .forth с текстом программы

Выходные данные: файл code с программой на языке мнемоник 

Пример запуска: `python3 -m src.code_compiler.compiling.compiling ../../../example/arrays/arrays.forth`

После запуска рядом с файлом forth появится папка build где будет лежать файл `code` с скомпилированной программой в язык мнемоник

### Компиляция

Процесс компиляции состоит из 3 этапов:
  1. Парсинг каждой секции - на этом этапе все секции одного типа объединяются для последующей компиляции
  2. Компиляция каждой из секций - на этом этапе происходит компиляция всех секций в определённом порядке: `_import_`, `_data_`, `_func_`, `_text_`
     такие блоки как `_import_` рекурсивно компилируют своё содержимое однако используя для переменных другое адресное пространство.  
      - Перевод базовых команд в мнемоники (`+` -> `+`, `0` -> `push_imm 0` и т.д.)
      - Разрешение сложных конструкций таких как циклы и ветвление по заготовленным заранее [шаблонам](./src/code_compiler/compiling/app/samples). 
        Данные шаблоны заранее составленными для общих случаев циклов или ветвелний 
  3. Перестановка секций в нужном порядке и запись в результирующий файл - на этом этапе результаты компиляции записываются в
     файл в определённом порядке, сначала идёт секция `.data` далее `.text` в котором идут сначала все скомпилированные функции, потом метка `_start`
     Показывающая место входа в программу и уже потом основная программа.

## Асемблер

---

### Интерфейс

Входные данные: файл с текстом программы на языке мнемоник и числовое значение размера памяти данный в байтах.

Выходные данные: бинарный файл в формате

```text

    ┌───────────┬───────────┬───────────────────────────────────┐
    │ 0... ..31 │ 32.. ..61 │ ................................. │
    ├───────────┼───────────┴───────────────────────────────────┤
    │  _start   │              data (инструкции)                │
    └───────────┴───────────────────────────────────────────────┘
```
где первые 4 байта это адрес входа в программу.

Пример запуска: `python3 -m src.code_compiler.assembly.assembly ../../../example/arrays/build/code 100`

После запуска рядом с файлом `code` появится папка `bin` в которой будут лежать 2 файла `instruction_memory` и `data_memory` в которых будут находиться инструкции и данные в бинарном фиде соответственно.

### Ассемблирование

На этапе ассемблирования команда преобразует мнемоники, описанные в секции `.text`, в машинный код с использованием [конфигурации инструкций](./src/code_compiler/config/instructions.yaml). При обнаружении метки `_start` её адрес записывается в первое машинное слово памяти инструкций как точка входа программы.

Каждая инструкция занимает 1 байт, за ней следует аргумент длиной 4 байта, если он предусмотрен.

Данные, описанные в секции `.data`, размещаются в бинарном файле памяти данных. Поддерживаются два типа записи:

- `word` — запись значения в 4 байта;
- `byte` — запись значения в 1 байт.

---

## Модель процессора

### Консольный интерфейс


Входные данные: путь к бинарным, сгенерированному компилятором, путь к конфигу .yaml, где описаны io, логи, ассерты

`
python3 -m src.stack_machine.start_cpu -c ../../example/arrays/arrays.yaml -b ../../example/arrays/build/bin/  -a 98
`


## Правила конфигурации


## Cхема

---

### DataPath

### ControlUnit


## Особенности работы модели:

---

## Тестирование

---
