# Система команд

---

Система команд относится к классу стековых архитектур с поддержкой SIMD операций. Основные особенности:
- Стековая модель вычислений
- Поддержка скалярных и векторных операций
- Фиксированный формат команд (8-битный опкод)
- Разделение на арифметико-логические, загрузки/сохранения и управления потоком команд

Все команды кодируются 8-битным опкодом (1 байт). Некоторые команды требуют аргумент (4 байта), которое следует сразу после опкода. 

---

## Скалярные инструкции
### Загрузка данных в data stack
#### `push_imm <value>`
- **Опкод**: 0x01
- **Описание**: Загружает значение в стек данных
- **Операция**: `dataStack.push(<value>)`
- **Такты**: 1
- **Микрокоманды**:
  - `<value> -> B`, `B + 0 -> alu_out`,`dataStack.push(alu_out)`

#### `lw_from_imm_addr <value>`
- **Опкод**: 0x02 
- **Описание**: Помещает в стек данных значение по адресу <value>
- **Операция**: `dataStack.push(mem[<value>])`
- **Такты**: 1
- **Микрокоманды**:
  - `<value> -> B`, `B + 0 -> alu_out`, `dataStack.push(mem[alu_out])`

#### `lw_from_a_addr`
- **Опкод**: 0x03
- **Описание**: Помещает в стек данных значение по адресу в регистре `A`
- **Операция**: `dataStack.push(mem[A])`
- **Такты**: 1
- **Микрокоманды**:
  - `A + 0 -> alu_out`, `dataStack.push(mem[alu_out])`

#### `lw_from_b_addr` 
- **Опкод**: 0x04
- **Описание**: Помещает в стек данных значение по адресу в регистре `B`
- **Операция**: `dataStack.push(mem[B])`  
- **Такты**: 1
- **Микрокоманды**:
  - `B + 0 -> alu_out`, `dataStack.push(mem[alu_out])`

#### `lw_from_a_addr_inc_a` 
- **Опкод**: 0x05
- **Описание**: Помещает в стек данных значение по адресу в регистре `A` после чего инкриминирует регистр `A`
- **Операция**: `dataStack.push(mem[A])`, `A + 1 -> A`  
- **Такты**: 3
- **Микрокоманды**:
  - `A + 0 -> alu_out`, `dataStack.push(mem[alu_out])`
  - `A + 1 -> alu_out`, `dataStack.push(alu_out)`
  - `T -> A`, `dataStack.pop()`

### Загрузка данных из data stack

#### `laod_T_a_pop` 
- **Опкод**: 0x06
- **Описание**: Сохраняет верх стека в регистр `A`, попит значение стека
- **Операция**: `dataStack.pop() -> A`  
- **Такты**: 1
- **Микрокоманды**:
  - `T -> A`, `dataStack.pop()`

#### `laod_T_b_push` 
- **Опкод**: 0x07
- **Описание**: Сохраняет верх стека в регистр `B`
- **Операция**: `dataStack.top() -> B`  
- **Такты**: 1
- **Микрокоманды**:
  - `T -> B`,

#### `sw_to_imm_addr <value>` 
- **Опкод**: 0x10
- **Описание**: Сохраняет верх стека по адрессу `<value>`, попит значение стека
- **Операция**: `dataStack.pop() -> mem[<value>]`
- **Такты**: 1
- **Микрокоманды**:
  - `<value> -> B`, `B + 0 -> alu_out`, `dataStack.pop() -> mem[alu_out]`

#### `sw_to_a_addr` 
- **Опкод**: 0x11 
- **Описание**: Сохраняет верх стека по адресу в регистре `A`, попит значение стека
- **Операция**: `dataStack.pop() -> mem[A]`
- **Такты**: 1
- **Микрокоманды**:
  - `A + 0 -> alu_out`, `dataStack.pop() -> mem[alu_out]`

#### `sw_to_b_addr` 
- **Опкод**: 0x12
- **Описание**: Сохраняет верх стека по адресу в регистре `B`, попит значение стека
- **Операция**: `dataStack.pop() -> mem[B]`
- **Такты**: 1
- **Микрокоманды**:
  - `B + 0 -> alu_out`, `dataStack.pop() -> mem[alu_out]`

#### `sw_to_a_addr_inc_a`
- **Опкод**: 0x13
- **Описание**: Сохраняет верх стека по адресу в регистре `A`, попит значение стека, инерементирует значение регистра `A` 
- **Операция**: `dataStack.pop() -> mem[A]`, `A + 1 -> A`  
- **Такты**: 3
- **Микрокоманды**:
  - `A + 0 -> alu_out`, `dataStack.pop() -> mem[alu_out]`
  - `A + 1 -> alu_out`, `dataStack.push(alu_out)`
  - `T -> A`, `dataStack.pop()`

#### `push_a` 
- **Опкод**: 0x14
- **Описание**: Пушит значение регистра `A` в стек
- **Операция**: `dataStack.push(A)`
- **Такты**: 1
- **Микрокоманды**:
  - `A + 0 -> alu_out`, `dataStack.push(alu_out)`

#### `push_b` 
- **Опкод**: 0x17
- **Описание**: Пушит значение регистра `B` в стек
- **Операция**: `dataStack.push(B)`
- **Такты**: 1
- **Микрокоманды**:
  - `B + 0 -> alu_out`, `dataStack.push(alu_out)`

### Управление data stack-ом

#### `dup` 
- **Опкод**: 0x08
- **Описание**: Дублирует верхнее значение стека
- **Операция**: `dataStack.push(dataStack.top())`  
- **Такты**: 1
- **Микрокоманды**:
  - `T -> B`, `B + 0 -> alu_out`, `dataStack.push(alu_out)`

#### `pop` 
- **Опкод**: 0x16
- **Описание**: Попит стек
- **Операция**: `dataStack.pop()`
- **Такты**: 1
- **Микрокоманды**:
  - `dataStack.pop()`

#### `over` 
- **Опкод**: 0x30
- **Описание**: Меняет 2 верхних значения стека местами
- **Операция**: `dataStack.top() <-> dataStack.second()`
- **Такты**: 1
- **Микрокоманды**:
  - `over`

### Бинарные операции над data stack


#### `<<` 
- **Опкод**: 0x24
- **Описание**: Сдвиг верхнего значения стека данных влево на один бит
- **Операция**: `dataStack.push(dataStack.pop() << 1)`
- **Такты**: 1
- **Микрокоманды**:
 - `dataStack.pop() << 1 -> alu_out`, `dataStack.push(alu_out)`

#### `>>` 
- **Опкод**: 0x25
- **Описание**: Сдвиг верхнего значения стека данных вправо на один бит
- **Операция**: `dataStack.push(dataStack.pop() >> 1)`
- **Такты**: 1
- **Микрокоманды**:
 - `dataStack.pop() >> 1 -> alu_out`, `dataStack.push(alu_out)`

#### `not` 
- **Опкод**: 0x26
- **Описание**: Инверсия битов верхнего значения стека данных
- **Операция**: `dataStack.push(~dataStack.pop())`
- **Такты**: 1
- **Микрокоманды**:
 - `~dataStack.pop() -> alu_out`, `dataStack.push(alu_out)`

#### `and` 
- **Опкод**: 0x28
- **Описание**: Логическое "И" двух верхних значений стека данных
- **Операция**: `dataStack.push(dataStack.pop() & dataStack.pop())`
- **Такты**: 1
- **Микрокоманды**:
  - `dataStack.pop() & dataStack.pop() -> alu_out`, `dataStack.push(alu_out)`

#### `or` 
- **Опкод**: 0x29
- **Описание**: Логическое "ИЛИ" двух верхних значений стека данных
- **Операция**: `dataStack.push(dataStack.pop() | dataStack.pop())`
- **Такты**: 1
- **Микрокоманды**:
  - `dataStack.pop() | dataStack.pop() -> alu_out`, `dataStack.push(alu_out)`


### Арифметические операции над data stack

#### `+` 
- **Опкод**: 0x20
- **Описание**: Сумма двух верхних значений стека данных
- **Операция**: `dataStack.push(dataStack.pop() + dataStack.pop())`
- **Такты**: 1
- **Микрокоманды**:
  - `dataStack.pop() + dataStack.pop() -> alu_out`, `dataStack.push(alu_out)` 

#### `-` 
- **Опкод**: 0x21
- **Описание**: Разность 2 верхних значений стека данных
- **Операция**: `dataStack.push(dataStack.pop() - dataStack.pop())`
- **Такты**: 1
- **Микрокоманды**:
 - `dataStack.pop() - dataStack.pop() -> alu_out`, `dataStack.push(alu_out)`

#### `*` 
- **Опкод**: 0x22
- **Описание**: Произведение 2 верхних значений стека данных
- **Операция**: `dataStack.push(dataStack.pop() * dataStack.pop())`
- **Такты**: 1
- **Микрокоманды**:
 - `dataStack.pop() * dataStack.pop() -> alu_out`, `dataStack.push(alu_out)`

#### `inc` 
- **Опкод**: 0x2A
- **Описание**: Инкрементами верхнего значения стека данных
- **Операция**: `dataStack.push(dataStack.pop() + 1)`
- **Такты**: 1
- **Микрокоманды**:
  - `dataStack.pop() + 1 -> alu_out`, `dataStack.push(alu_out)`


## Векторные операции 

В данном блоке под "операция над верхним значением стека векторов" имеется ввиду сразу над четырьмя 4 байтовыми
значениями записанными просто в одном 128 битном слове, которое храниться на веку 128 битного стека векторов.
Т.е. если два верхних значений стека выглядит как (1, 2, 3, 4), (2, 3, 4, 5) и например сумма двух верхних значений стека это (1, 2, 3, 4) + (2, 3, 4, 5) = (3, 5, 7, 9)

### Загрузка данных в vector stack

#### `v_lw_from_imm_addr <value>` 
- **Опкод**: 0x80 
- **Описание**: Помещает в стек векторов значение по адресу `<value>`
- **Операция**: `vectorStack.push(mem[<value>])`
- **Такты**: 2
- **Микрокоманды**:
  - `<value> -> B`, `B + 0 -> alu_out`
  - `simd`, `vectorStack.push(mem[alu_out])`

#### `v_lw_from_a_addr` 
- **Опкод**: 0x81 
- **Описание**: Помещает в стек векторов значение по адресу в регистре `A`
- **Операция**: `vectorStack.push(mem[A])`
- **Такты**: 2
- **Микрокоманды**:
  - `A + 0 -> alu_out`
  - `simd`, `vectorStack.push(mem[alu_out])`

#### `v_lw_from_b_addr` 
- **Опкод**: 0x82 
- **Описание**: Помещает в стек векторов значение по адресу в регистре `B`
- **Операция**: `vectorStack.push(mem[B])`  
- **Такты**: 2
- **Микрокоманды**:
  - `B + 0 -> alu_out`
  - `simd`, `vectorStack.push(mem[alu_out])`

### Загрузка данных из data stack

#### `v_sw_to_imm_addr <value>` 
- **Опкод**: 0x90 
- **Описание**: Сохраняет верх стека векторов по адрессу `<value>`, попит значение стека
- **Операция**: `vectorStack.pop() -> mem[<value>]`
- **Такты**: 2
- **Микрокоманды**:
  - `<value> -> B`, `B + 0 -> alu_out`
  - `simd`, `vectorStack.pop() -> mem[alu_out]`

#### `v_sw_to_a_addr` 
- **Опкод**: 0x91 
- **Описание**: Сохраняет верх стека векторов по адресу в регистре `A`, попит значение стека
- **Операция**: `vectorStack.pop() -> mem[A]`
- **Такты**: 2
- **Микрокоманды**:
  - `A + 0 -> alu_out`
  - `simd`, `vectorStack.pop() -> mem[alu_out]`

#### `v_sw_to_b_addr` 
- **Опкод**: 0x92 
- **Описание**: Сохраняет верх стека векторов по адресу в регистре `B`, попит значение стека
- **Операция**: `vectorStack.pop() -> mem[B]`
- **Такты**: 2
- **Микрокоманды**:
  - `B + 0 -> alu_out`
  - `simd`, `vectorStack.pop() -> mem[alu_out]`

### Управление vector stack-ом

#### `v_pop` 
- **Опкод**: 0x93 
- **Описание**: Попит значение стека векторов
- **Операция**: `vectorStack.pop()`
- **Такты**: 1
- **Микрокоманды**:
  - `simd`, `vectorStack.pop()`

#### `v_over` 
- **Опкод**: 0xB0 
- **Описание**: Меняет местами два верхних значения стека векторов
- **Операция**: `vectorStack.top() <-> vectorStack.second()`
- **Такты**: 1
- **Микрокоманды**:
  - `simd`, `over`


### Бинарные операции над vector stack

#### `v<<` 
- **Опкод**: 0xA4 
- **Описание**: Сдвиг верхнего значения стека векторов влево на один бит
- **Операция**: `vectorStack.push(vectorStack.pop() << 1)`
- **Такты**: 1
- **Микрокоманды**:
 - `simd`, `vectorStack.pop() << 1 -> alu_out`, `vectorStack.push(alu_out)`

#### `v>>` 
- **Опкод**: 0xA5 
- **Описание**: Сдвиг верхнего значения стека векторов вправо на один бит
- **Операция**: `vectorStack.push(vectorStack.pop() >> 1)`
- **Такты**: 1
- **Микрокоманды**:
 - `simd`, `vectorStack.pop() >> 1 -> alu_out`, `vectorStack.push(alu_out)`

#### `v_not` 
- **Опкод**: 0xA6 
- **Описание**: Инверсия битов верхнего значения стека векторов
- **Операция**: `vectorStack.push(~vectorStack.pop())`
- **Такты**: 1
- **Микрокоманды**:
 - `simd`, `~vectorStack.pop() -> alu_out`, `vectorStack.push(alu_out)`

#### `v_and` 
- **Опкод**: 0xA8 
- **Описание**: Логическое "И" двух верхних значений стека векторов
- **Операция**: `vectorStack.push(vectorStack.pop() & vectorStack.pop())`
- **Такты**: 1
- **Микрокоманды**:
  - `simd`, `vectorStack.pop() & vectorStack.pop() -> alu_out`, `vectorStack.push(alu_out)`

#### `v_or` 
- **Опкод**: 0xA9 
- **Описание**: Логическое "ИЛИ" двух верхних значений стека векторов
- **Операция**: `vectorStack.push(vectorStack.pop() | vectorStack.pop())`
- **Такты**: 1
- **Микрокоманды**:
  - `simd`, `vectorStack.pop() | vectorStack.pop() -> alu_out`, `vectorStack.push(alu_out)`

### Арифметические операции над vector stack

#### `v+` 
- **Опкод**: 0xA0 
- **Описание**: Сумма двух верхних значений стека векторов
- **Операция**: `vectorStack.push(vectorStack.pop() + vectorStack.pop())`
- **Такты**: 1
- **Микрокоманды**:
  - `simd`, `vectorStack.pop() + vectorStack.pop() -> alu_out`, `vectorStack.push(alu_out)` 

#### `v-` 
- **Опкод**: 0xA1 
- **Описание**: Разность двух верхних значений стека векторов
- **Операция**: `vectorStack.push(vectorStack.pop() - vectorStack.pop())`
- **Такты**: 1
- **Микрокоманды**:
 - `simd`, `vectorStack.pop() - vectorStack.pop() -> alu_out`, `vectorStack.push(alu_out)`

#### `v*` 
- **Опкод**: 0xA2 
- **Описание**: Произведение двух верхних значений стека векторов
- **Операция**: `vectorStack.push(vectorStack.pop() * vectorStack.pop())`
- **Такты**: 1
- **Микрокоманды**:
 - `simd`, `vectorStack.pop() * vectorStack.pop() -> alu_out`, `vectorStack.push(alu_out)`

#### `v_inc` 
- **Опкод**: 0xAA 
- **Описание**: Инкрементами двух верхних значений стека векторов
- **Операция**: `vectorStack.push(vectorStack.pop() + 1)`
- **Такты**: 1
- **Микрокоманды**:
  - `simd`, `vectorStack.pop() + 1 -> alu_out`, `vectorStack.push(alu_out)`


## Управление потоком выполнения

#### `jmp <value>` 
- **Опкод**: 0x40
- **Описание**: Переход на `<value>` значений инструкций
- **Операция**: `PC + <value> -> PC`
- **Такты**: 1
- **Микрокоманды**:
  - `<value> -> B`, `B + PC -> alu_out`, `alu_out -> PC`

#### `call <value>` 
- **Опкод**: 0x41
- **Описание**: Переход на `<value>` значений инструкций с записью адреса возврата
- **Операция**: `returnStack.push(PC)`, `PC + <value> -> PC`
- **Такты**: 1
- **Микрокоманды**:
  - `<value> -> B`, `B + PC -> alu_out`, `returnStack.push(PC)`, `alu_out -> PC`

#### `ret` 
- **Опкод**: 0x42
- **Описание**: Возврат процедуры
- **Операция**: `returnStack.pop() -> PC`
- **Такты**: 1
- **Микрокоманды**:
  - `returnStack.pop() -> PC`

#### `if <value>`  
- **Опкод**: 0x43
- **Описание**: Переход на `<value>` инструкций верхнее значение стека == 0 
- **Операция**: `if(dataStack.pop() == 0): PC + <value> -> PC`
- **Такты**: 1
- **Микрокоманды**:
  - `<value> -> B`, `dataStack.pop() == 0 ? B + PC -> alu_out : PC -> alu_out`, `alu_out -> PC`

#### `-if <value>` 
- **Опкод**: 0x44
- **Описание**: Переход на `<value>` инструкций если верхнее значение стека >= 0 
- **Операция**: `if(dataStack.pop() >= 0): PC + <value> -> PC`
- **Такты**: 1
- **Микрокоманды**:
  - `<value> -> B`, `dataStack.pop() >= 0 ? B + PC -> alu_out : PC -> alu_out`, `alu_out -> PC`

#### `halt` 
- **Опкод**: 0x45
- **Описание**: отсанов



Все микро команды задаются при помощи файла конфигурации который можно найти [тут](./../src/stack_machine/config/mc.yaml). 

---

# Микрокод и способ кодирования
Каждому сигналу сопоставлен один бит в микрокоманде, в одной микрокоманде 32 бита

Табличка номера бита и его сигнал:


| Номер бита | Сигнал     | Описание                                                                                                          | 
|------------|------------|-------------------------------------------------------------------------------------------------------------------|
| `0`        | simd       | установка является ли операция векторной (т.е. с каким стеком мы работаем)                                        | 
| `1`        | open_a     | открыть вход с регистра `A` в левый вход `alu`                                                                    |
| `2`        | open_b     | открыть вход с регистра `B` в левый вход `alu`                                                                    |
| `3`        | open_l     | открыть вход верха стека в левый вход `alu` с попом стека                                                         |
| `4`        | open_r     | открыть вход верха стека в правый вход `alu` с попом стека                                                        |
| `5`        | open_r_pc  | открыть вход с регистра `PC` в правый вход `alu`                                                                  |
| `6`        | add        | сложить левый и правый входы `alu`                                                                                |
| `7`        | sub        | вычесть из левого правый вход `alu`                                                                               |
| `8`        | and        | логическое "И" правого и левого входа `alu`                                                                       |
| `9`        | or         | логическое "ИЛИ" правого и левого входа `alu`                                                                     |
| `10`       | inc        | инкремент левого входа `alu`                                                                                      |
| `11`       | mul        | умножить левый и правый входы `alu`                                                                               |
| `12`       | div        | разделить левый и правый входы `alu`                                                                              |
| `13`       | shl        | сдвинуть в лево левый вход `alu`                                                                                  |
| `14`       | shr        | сдвинуть в право левый вход `alu`                                                                                 |
| `15`       | not        | инвертировать биты левого входа `alu`                                                                             |
| `16`       | if         | если верх стека данных равен 0 то сложить правый и левый вход `alu` иначе просто пропустить левый вход            |
| `17`       | -if        | если верх стека данных больше или равен 0 то сложить правый и левый вход `alu` иначе просто пропустить левый вход | 
| `18`       | write      | записать данные верха стека по адресу выхода из `alu`                                                             |
| `19`       | read       | прочитать данные в стек по адресу выхода из `alu`                                                                 |
| `20`       | load_imm   | загрузить значение из imm в регистр `B`                                                                           |
| `21`       | push_stack | загрузить результат `alu` в стек                                                                                  |
| `22`       | pop_stack  | попнуть стек                                                                                                      |
| `23`       | push_ret   | запушить значение из регистра `PC` в стек возвратов                                                               |
| `24`       | load_T_a   | загрузить значение верха стека в регистр `A`                                                                      |
| `25`       | load_T_b   | загрузить значение верха стека в регистр `B`                                                                      |
| `26`       | fetch_pc   | загрузить результат из `alu` в регистр `PC`                                                                       |
| `27`       | restore_pc | загрузить значение верха стека возвратов в регистр `PC` c попом стека возвратов                                   |
| `28`       | kill_cpu   | остановить работу процессора                                                                                      |
| `29`       | call       | сохранить регистр `PC` в стек возвратов и загрузить значение из `alu` в регистр `PC`                              |
| `30`       | over       | поменять два верхних значений стека местами                                                                       |
| `31`       | term_mc    | конец микропрограммы                                                                                              |

Например (все кодировки в big-endian):
 - команда `push_imm` будет кодироваться вот такие микрокодом 
   1. `01000100 00000000 00110000 10000000`
 - команда `lw_from_a_addr_inc_a` будет кодироваться вот такие микрокодом
   1. `01000010 00000000 00001000 00000000`
   2. `00000010 00000100 00100000 00000000`
   3. `00000000 00000000 01000000 10000001`
