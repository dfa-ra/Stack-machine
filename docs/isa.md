# ISA

---

Система команд относится к классу стековых архитектур с поддержкой SIMD операций. Основные особенности:
- Стековая модель вычислений
- Поддержка скалярных и векторных операций
- Фиксированный формат команд (8-битный опкод)
- Разделение на арифметико-логические, загрузки/сохранения и управления потоком команд

Все команды кодируются 8-битным опкодом (1 байт). Некоторые команды требуют аргумент (4 байта), которое следует сразу после опкода. 

---

## Скалярные инструкции
### Загрузка данных в data stack
#### `push_imm <value>`
- **Опкод**: 0x01
- **Описание**: Загружает значение в стек данных
- **Операция**: `dataStack.push(<value>)`
- **Такты**: 1
- **Микрокоманды**:
  - `<value> -> B`, `B + 0 -> alu_out`,`dataStack.push(alu_out)`

#### `lw_from_imm_addr <value>`
- **Опкод**: 0x02 
- **Описание**: Помещает в стек данных значение по адресу <value>
- **Операция**: `dataStack.push(mem[<value>])`
- **Такты**: 1
- **Микрокоманды**:
  - `<value> -> B`, `B + 0 -> alu_out`, `dataStack.push(mem[alu_out])`

#### `lw_from_a_addr`
- **Опкод**: 0x03
- **Описание**: Помещает в стек данных значение по адресу в регистре `A`
- **Операция**: `dataStack.push(mem[A])`
- **Такты**: 1
- **Микрокоманды**:
  - `A + 0 -> alu_out`, `dataStack.push(mem[alu_out])`

#### `lw_from_b_addr` 
- **Опкод**: 0x04
- **Описание**: Помещает в стек данных значение по адресу в регистре `B`
- **Операция**: `dataStack.push(mem[B])`  
- **Такты**: 1
- **Микрокоманды**:
  - `B + 0 -> alu_out`, `dataStack.push(mem[alu_out])`

#### `lw_from_a_addr_inc_a` 
- **Опкод**: 0x05
- **Описание**: Помещает в стек данных значение по адресу в регистре `A` после чего инкриминирует регистр `A`
- **Операция**: `dataStack.push(mem[A])`, `A + 1 -> A`  
- **Такты**: 3
- **Микрокоманды**:
  - `A + 0 -> alu_out`, `dataStack.push(mem[alu_out])`
  - `A + 1 -> alu_out`, `dataStack.push(alu_out)`
  - `T -> A`, `dataStack.pop()`

### Загрузка данных из data stack

#### `laod_T_a_pop` 
- **Опкод**: 0x06
- **Описание**: Сохраняет верх стека в регистр `A`, попит значение стека
- **Операция**: `dataStack.pop() -> A`  
- **Такты**: 1
- **Микрокоманды**:
  - `T -> A`, `dataStack.pop()`

#### `laod_T_b_push` 
- **Опкод**: 0x07
- **Описание**: Сохраняет верх стека в регистр `B`
- **Операция**: `dataStack.top() -> B`  
- **Такты**: 1
- **Микрокоманды**:
  - `T -> B`,

#### `sw_to_imm_addr <value>` 
- **Опкод**: 0x10
- **Описание**: Сохраняет верх стека по адрессу `<value>`, попит значение стека
- **Операция**: `dataStack.pop() -> mem[<value>]`
- **Такты**: 1
- **Микрокоманды**:
  - `<value> -> B`, `B + 0 -> alu_out`, `dataStack.pop() -> mem[alu_out]`

#### `sw_to_a_addr` 
- **Опкод**: 0x11 
- **Описание**: Сохраняет верх стека по адресу в регистре `A`, попит значение стека
- **Операция**: `dataStack.pop() -> mem[A]`
- **Такты**: 1
- **Микрокоманды**:
  - `A + 0 -> alu_out`, `dataStack.pop() -> mem[alu_out]`

#### `sw_to_b_addr` 
- **Опкод**: 0x12
- **Описание**: Сохраняет верх стека по адресу в регистре `B`, попит значение стека
- **Операция**: `dataStack.pop() -> mem[B]`
- **Такты**: 1
- **Микрокоманды**:
  - `B + 0 -> alu_out`, `dataStack.pop() -> mem[alu_out]`

#### `sw_to_a_addr_inc_a`
- **Опкод**: 0x13
- **Описание**: Сохраняет верх стека по адресу в регистре `A`, попит значение стека, инерементирует значение регистра `A` 
- **Операция**: `dataStack.pop() -> mem[A]`, `A + 1 -> A`  
- **Такты**: 3
- **Микрокоманды**:
  - `A + 0 -> alu_out`, `dataStack.pop() -> mem[alu_out]`
  - `A + 1 -> alu_out`, `dataStack.push(alu_out)`
  - `T -> A`, `dataStack.pop()`

#### `push_a` 
- **Опкод**: 0x14
- **Описание**: Пушит значение регистра `A` в стек
- **Операция**: `dataStack.push(A)`
- **Такты**: 1
- **Микрокоманды**:
  - `A + 0 -> alu_out`, `dataStack.push(alu_out)`

#### `push_b` 
- **Опкод**: 0x17
- **Описание**: Пушит значение регистра `B` в стек
- **Операция**: `dataStack.push(B)`
- **Такты**: 1
- **Микрокоманды**:
  - `B + 0 -> alu_out`, `dataStack.push(alu_out)`

### Управление data stack-ом

#### `dup` 
- **Опкод**: 0x08
- **Описание**: Дублирует верхнее значение стека
- **Операция**: `dataStack.push(dataStack.top())`  
- **Такты**: 1
- **Микрокоманды**:
  - `T -> B`, `B + 0 -> alu_out`, `dataStack.push(alu_out)`

#### `pop` 
- **Опкод**: 0x16
- **Описание**: Попит стек
- **Операция**: `dataStack.pop()`
- **Такты**: 1
- **Микрокоманды**:
  - `dataStack.pop()`

#### `over` 
- **Опкод**: 0x30
- **Описание**: Меняет 2 верхних значения стека местами
- **Операция**: `dataStack.top() <-> dataStack.second()`
- **Такты**: 1
- **Микрокоманды**:
  - `over`

### Бинарные операции над data stack


#### `<<` 
- **Опкод**: 0x24
- **Описание**: Сдвиг верхнего значения стека данных влево на один бит
- **Операция**: `dataStack.push(dataStack.pop() << 1)`
- **Такты**: 1
- **Микрокоманды**:
 - `dataStack.pop() << 1 -> alu_out`, `dataStack.push(alu_out)`

#### `>>` 
- **Опкод**: 0x25
- **Описание**: Сдвиг верхнего значения стека данных вправо на один бит
- **Операция**: `dataStack.push(dataStack.pop() >> 1)`
- **Такты**: 1
- **Микрокоманды**:
 - `dataStack.pop() >> 1 -> alu_out`, `dataStack.push(alu_out)`

#### `not` 
- **Опкод**: 0x26
- **Описание**: Инверсия битов верхнего значения стека данных
- **Операция**: `dataStack.push(~dataStack.pop())`
- **Такты**: 1
- **Микрокоманды**:
 - `~dataStack.pop() -> alu_out`, `dataStack.push(alu_out)`

#### `and` 
- **Опкод**: 0x28
- **Описание**: Логическое "И" двух верхних значений стека данных
- **Операция**: `dataStack.push(dataStack.pop() & dataStack.pop())`
- **Такты**: 1
- **Микрокоманды**:
  - `dataStack.pop() & dataStack.pop() -> alu_out`, `dataStack.push(alu_out)`

#### `or` 
- **Опкод**: 0x29
- **Описание**: Логическое "ИЛИ" двух верхних значений стека данных
- **Операция**: `dataStack.push(dataStack.pop() | dataStack.pop())`
- **Такты**: 1
- **Микрокоманды**:
  - `dataStack.pop() | dataStack.pop() -> alu_out`, `dataStack.push(alu_out)`


### Арифметические операции над data stack

#### `+` 
- **Опкод**: 0x20
- **Описание**: Сумма двух верхних значений стека данных
- **Операция**: `dataStack.push(dataStack.pop() + dataStack.pop())`
- **Такты**: 1
- **Микрокоманды**:
  - `dataStack.pop() + dataStack.pop() -> alu_out`, `dataStack.push(alu_out)` 

#### `-` 
- **Опкод**: 0x21
- **Описание**: Разность 2 верхних значений стека данных
- **Операция**: `dataStack.push(dataStack.pop() - dataStack.pop())`
- **Такты**: 1
- **Микрокоманды**:
 - `dataStack.pop() - dataStack.pop() -> alu_out`, `dataStack.push(alu_out)`

#### `*` 
- **Опкод**: 0x22
- **Описание**: Произведение 2 верхних значений стека данных
- **Операция**: `dataStack.push(dataStack.pop() * dataStack.pop())`
- **Такты**: 1
- **Микрокоманды**:
 - `dataStack.pop() * dataStack.pop() -> alu_out`, `dataStack.push(alu_out)`

#### `inc` 
- **Опкод**: 0x2A
- **Описание**: Инкрементами верхнего значения стека данных
- **Операция**: `dataStack.push(dataStack.pop() + 1)`
- **Такты**: 1
- **Микрокоманды**:
  - `dataStack.pop() + 1 -> alu_out`, `dataStack.push(alu_out)`


## Векторные операции 

В данном блоке под "операция над верхним значением стека векторов" имеется ввиду сразу над четырьмя 4 байтовыми
значениями записанными просто в одном 128 битном слове, которое храниться на веку 128 битного стека векторов.
Т.е. верхнее значение стека выглядит как (1, 2, 3, 4) и например сумма двух верхних значений стека это (1, 2, 3, 4) + (1, 2, 3, 4) = (2, 4, 6, 8)

### Загрузка данных в vector stack

#### `v_lw_from_imm_addr <value>` 
- **Опкод**: 0x80 
- **Описание**: Помещает в стек векторов значение по адресу `<value>`
- **Операция**: `vectorStack.push(mem[<value>])`
- **Такты**: 2
- **Микрокоманды**:
  - `<value> -> B`, `B + 0 -> alu_out`
  - `simd`, `vectorStack.push(mem[alu_out])`

#### `v_lw_from_a_addr` 
- **Опкод**: 0x81 
- **Описание**: Помещает в стек векторов значение по адресу в регистре `A`
- **Операция**: `vectorStack.push(mem[A])`
- **Такты**: 2
- **Микрокоманды**:
  - `A + 0 -> alu_out`
  - `simd`, `vectorStack.push(mem[alu_out])`

#### `v_lw_from_b_addr` 
- **Опкод**: 0x82 
- **Описание**: Помещает в стек векторов значение по адресу в регистре `B`
- **Операция**: `vectorStack.push(mem[B])`  
- **Такты**: 2
- **Микрокоманды**:
  - `B + 0 -> alu_out`
  - `simd`, `vectorStack.push(mem[alu_out])`

### Загрузка данных из data stack

#### `v_sw_to_imm_addr <value>` 
- **Опкод**: 0x90 
- **Описание**: Сохраняет верх стека векторов по адрессу `<value>`, попит значение стека
- **Операция**: `vectorStack.pop() -> mem[<value>]`
- **Такты**: 2
- **Микрокоманды**:
  - `<value> -> B`, `B + 0 -> alu_out`
  - `simd`, `vectorStack.pop() -> mem[alu_out]`

#### `v_sw_to_a_addr` 
- **Опкод**: 0x91 
- **Описание**: Сохраняет верх стека векторов по адресу в регистре `A`, попит значение стека
- **Операция**: `vectorStack.pop() -> mem[A]`
- **Такты**: 2
- **Микрокоманды**:
  - `A + 0 -> alu_out`
  - `simd`, `vectorStack.pop() -> mem[alu_out]`

#### `v_sw_to_b_addr` 
- **Опкод**: 0x92 
- **Описание**: Сохраняет верх стека векторов по адресу в регистре `B`, попит значение стека
- **Операция**: `vectorStack.pop() -> mem[B]`
- **Такты**: 2
- **Микрокоманды**:
  - `B + 0 -> alu_out`
  - `simd`, `vectorStack.pop() -> mem[alu_out]`

### Управление vector stack-ом

#### `v_pop` 
- **Опкод**: 0x93 
- **Описание**: Попит значение стека векторов
- **Операция**: `vectorStack.pop()`
- **Такты**: 1
- **Микрокоманды**:
  - `simd`, `vectorStack.pop()`

#### `v_over` 
- **Опкод**: 0xB0 
- **Описание**: Меняет местами два верхних значения стека векторов
- **Операция**: `vectorStack.top() <-> vectorStack.second()`
- **Такты**: 1
- **Микрокоманды**:
  - `simd`, `over`


### Бинарные операции над vector stack

#### `v<<` 
- **Опкод**: 0xA4 
- **Описание**: Сдвиг верхнего значения стека векторов влево на один бит
- **Операция**: `vectorStack.push(vectorStack.pop() << 1)`
- **Такты**: 1
- **Микрокоманды**:
 - `simd`, `vectorStack.pop() << 1 -> alu_out`, `vectorStack.push(alu_out)`

#### `v>>` 
- **Опкод**: 0xA5 
- **Описание**: Сдвиг верхнего значения стека векторов вправо на один бит
- **Операция**: `vectorStack.push(vectorStack.pop() >> 1)`
- **Такты**: 1
- **Микрокоманды**:
 - `simd`, `vectorStack.pop() >> 1 -> alu_out`, `vectorStack.push(alu_out)`

#### `v_not` 
- **Опкод**: 0xA6 
- **Описание**: Инверсия битов верхнего значения стека векторов
- **Операция**: `vectorStack.push(~vectorStack.pop())`
- **Такты**: 1
- **Микрокоманды**:
 - `simd`, `~vectorStack.pop() -> alu_out`, `vectorStack.push(alu_out)`

#### `v_and` 
- **Опкод**: 0xA8 
- **Описание**: Логическое "И" двух верхних значений стека векторов
- **Операция**: `vectorStack.push(vectorStack.pop() & vectorStack.pop())`
- **Такты**: 1
- **Микрокоманды**:
  - `simd`, `vectorStack.pop() & vectorStack.pop() -> alu_out`, `vectorStack.push(alu_out)`

#### `v_or` 
- **Опкод**: 0xA9 
- **Описание**: Логическое "ИЛИ" двух верхних значений стека векторов
- **Операция**: `vectorStack.push(vectorStack.pop() | vectorStack.pop())`
- **Такты**: 1
- **Микрокоманды**:
  - `simd`, `vectorStack.pop() | vectorStack.pop() -> alu_out`, `vectorStack.push(alu_out)`

### Арифметические операции над vector stack

#### `v+` 
- **Опкод**: 0xA0 
- **Описание**: Сумма двух верхних значений стека векторов
- **Операция**: `vectorStack.push(vectorStack.pop() + vectorStack.pop())`
- **Такты**: 1
- **Микрокоманды**:
  - `simd`, `vectorStack.pop() + vectorStack.pop() -> alu_out`, `vectorStack.push(alu_out)` 

#### `v-` 
- **Опкод**: 0xA1 
- **Описание**: Разность двух верхних значений стека векторов
- **Операция**: `vectorStack.push(vectorStack.pop() - vectorStack.pop())`
- **Такты**: 1
- **Микрокоманды**:
 - `simd`, `vectorStack.pop() - vectorStack.pop() -> alu_out`, `vectorStack.push(alu_out)`

#### `v*` 
- **Опкод**: 0xA2 
- **Описание**: Произведение двух верхних значений стека векторов
- **Операция**: `vectorStack.push(vectorStack.pop() * vectorStack.pop())`
- **Такты**: 1
- **Микрокоманды**:
 - `simd`, `vectorStack.pop() * vectorStack.pop() -> alu_out`, `vectorStack.push(alu_out)`

#### `v_inc` 
- **Опкод**: 0xAA 
- **Описание**: Инкрементами двух верхних значений стека векторов
- **Операция**: `vectorStack.push(vectorStack.pop() + 1)`
- **Такты**: 1
- **Микрокоманды**:
  - `simd`, `vectorStack.pop() + 1 -> alu_out`, `vectorStack.push(alu_out)`


## Управление потоком выполнения

#### `jmp <value>` 
- **Опкод**: 0x40
- **Описание**: Переход на `<value>` значений инструкций
- **Операция**: `PC + <value> -> PC`
- **Такты**: 1
- **Микрокоманды**:
  - `<value> -> B`, `B + PC -> alu_out`, `alu_out -> PC`

#### `call <value>` 
- **Опкод**: 0x41
- **Описание**: Переход на `<value>` значений инструкций с записью адреса возврата
- **Операция**: `returnStack.push(PC)`, `PC + <value> -> PC`
- **Такты**: 1
- **Микрокоманды**:
  - `<value> -> B`, `B + PC -> alu_out`, `returnStack.push(PC)`, `alu_out -> PC`

#### `ret` 
- **Опкод**: 0x42
- **Описание**: Возврат процедуры
- **Операция**: `returnStack.pop() -> PC`
- **Такты**: 1
- **Микрокоманды**:
  - `returnStack.pop() -> PC`

#### `if <value>`  
- **Опкод**: 0x43
- **Описание**: Переход на `<value>` инструкций верхнее значение стека == 0 
- **Операция**: `if(dataStack.pop() == 0): PC + <value> -> PC`
- **Такты**: 1
- **Микрокоманды**:
  - `<value> -> B`, `dataStack.pop() == 0 ? B + PC -> alu_out : PC -> alu_out`, `alu_out -> PC`

#### `-if <value>` 
- **Опкод**: 0x44
- **Описание**: Переход на `<value>` инструкций если верхнее значение стека >= 0 
- **Операция**: `if(dataStack.pop() >= 0): PC + <value> -> PC`
- **Такты**: 1
- **Микрокоманды**:
  - `<value> -> B`, `dataStack.pop() >= 0 ? B + PC -> alu_out : PC -> alu_out`, `alu_out -> PC`

#### `halt` 
- **Опкод**: 0x45
- **Описание**: отсанов

---

Все микро команды задаются при помощи файла конфигурации который можно найти [тут](./../src/stack_machine/config/mc.yaml). 